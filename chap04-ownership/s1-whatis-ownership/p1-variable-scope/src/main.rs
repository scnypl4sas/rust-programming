fn main() {
    // 栈（Stack）与堆（Heap）
    // 栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）。
    // 想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。
    // 增加数据叫做 进栈（pushing onto the stack），而移出数据叫做 出栈（popping off the stack）。
    // 在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。
    // 操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。
    // 这个过程称作 在堆上分配内存（allocating on the heap），有时简称为 “分配”（allocating）。
    // 将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。

    // 所有权规则
    // 1. Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
    // 2. 值有且只有一个所有者。
    // 3. 当所有者（变量）离开作用域，这个值将被丢弃。

                        // s 在这里无效, 它尚未声明
    let s = "hello";    // 从此处起，s 是有效的

    // String 类型被分配到堆（Heap）上，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String
    // 两个冒号（::）是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）下
    let mut s = String::from("hello"); // 从此处起，s 是有效的
    s.push_str(", world!"); // push_str() 在字符串后追加字面值
    println!("{}", s); // 将打印 `hello, world!`

    // 对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：
    // * 必须在运行时向操作系统请求内存。
    // * 需要一个当我们处理完 String 时将内存返回给操作系统的方法。

    // 变量与数据交互的方式（一）：移动
    let x = 5; // 将 5 绑定到 x
    let y = x; // 生成一个值 x 的拷贝并绑定到 y, 所以这两个 5 被放入了栈中
    // 像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。

    // String 由三部分组成，如图左侧所示：
    // 一个指向存放字符串内容内存的指针;
    // 一个长度，表示 String 的内容当前使用了多少字节的内存。
    // 一个容量, 容量是 String 从操作系统总共获取了多少字节的内存。
    let s1 = String::from("hello");
    let s2 = s1; // 将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。并没有复制指针指向的堆上数据。
    // 把 s1 赋给 s2 之后，s1 就不再有效。如果 println!("{}, world!", s1); 会报错 error[E0382]: use of moved value: `s1`
    // 因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），上面的例子可以解读为 s1 被 移动 到了 s2 中。
    // 因为只有 s2 是有效的，当其离开作用域，它就释放自己的内存，完毕。

    // 变量与数据交互的方式（二）：克隆
    // 如果确实需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据 （指针），可以使用一个叫做 clone 的通用函数。
    let s1 = String::from("hello");
    let s2 = s1.clone();

    // 只在栈上的数据：拷贝
    let x = 5;
    let y = x;
    println!("x = {}, y = {}", x, y);
    // 整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。

}  // 此作用域已结束，s 不再有效

